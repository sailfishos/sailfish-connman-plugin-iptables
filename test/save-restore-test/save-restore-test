#!/bin/bash

SOURCES="../common/test_send ../common/test_output ../common/test_log ../common/test_service ../common/test_check"

IPTABLES_SAVE_FILE="/tmp/sailfish_iptables.filter.$RANDOM"

REQUIRED_COMMANDS_BASE="dbus-send grep id dirname"
REQUIRED_COMMANDS_ROOT="$REQUIRED_COMMANDS_BASE iptables iptables-save iptables-restore systemctl"

CUSTOM_CHAIN="CUSTOM1"

TEST_CHAINS="INPUT OUTPUT $CUSTOM_CHAIN"

TEST_TARGETS="ACCEPT DROP REJECT $CUSTOM_CHAIN"

IP_INPUTS[0]='string:192.168.10.1 string:'
IP_INPUTS[1]='string: string:192.168.10.2'
IP_INPUTS[2]='string:192.168.10.1 string:192.168.10.2'
IP_INPUTS[3]='' # Empty as last

IP_VERIFY[0]='192.168.10.1'
IP_VERIFY[1]='192.168.10.2'
IP_VERIFY[2]='192.168.10.1.*192.168.10.2'
IP_VERIFY[3]=''

IP_INPUTS_VERIFY[0]="-s ${IP_VERIFY[0]}/32"
IP_INPUTS_VERIFY[1]="-d ${IP_VERIFY[1]}/32"
IP_INPUTS_VERIFY[2]="-s ${IP_VERIFY[0]}/32 -d ${IP_VERIFY[1]}/32"
IP_INPUTS_VERIFY[3]=''

PROTO_VERIFY[0]='-p udp -m udp'
PROTO_VERIFY[1]='-p tcp -m tcp'
PROTO_VERIFY[2]='-p tcp -m tcp'
PROTO_VERIFY[3]=''

PORT_INPUTS[0]='uint16:23 uint16:0 uint32:17'
PORT_INPUTS[1]='uint16:0 uint16:873 uint32:6'
PORT_INPUTS[2]='uint16:80 uint16:443 uint32:6'
PORT_INPUTS[3]=''

PORT_INPUTS_VERIFY[0]='--sport 23'
PORT_INPUTS_VERIFY[1]='--dport 873'
PORT_INPUTS_VERIFY[2]='--sport 80 --dport 443'
PORT_INPUTS_VERIFY[3]=''

PORT_RANGE_INPUTS[0]='uint16:23 uint16:24 uint16:0 uint16:0 uint32:17'
PORT_RANGE_INPUTS[1]='uint16:0 uint16:0 uint16:1000 uint16:2000 uint32:6'
PORT_RANGE_INPUTS[2]='uint16:23 uint16:24 uint16:1000 uint16:2000 uint32:6'
PORT_RANGE_INPUTS[3]=''

SERVICE_INPUTS[0]='string:telnet string: uint32:17'
SERVICE_INPUTS[1]='string: string:rsync uint32:6'
SERVICE_INPUTS[2]='string:http string:https uint32:6'
SERVICE_INPUTS[3]=''

PORT_RANGE_INPUTS_VERIFY[0]='spts:23:24'
PORT_RANGE_INPUTS_VERIFY[1]='dpts:1000:2000'
PORT_RANGE_INPUTS_VERIFY[2]='spts:23:24 dpts:1000:2000'
PORT_RANGE_INPUTS_VERIFY[3]=''

ICMP_INPUTS[0]='uint16:0 uint16:0'
ICMP_INPUTS[1]='uint16:8 uint16:0'
ICMP_INPUTS[2]='uint16:43 uint16:0'
ICMP_INPUTS[3]=''

ICMP_INPUTS_VERIFY[0]='-p icmp -m icmp --icmp-type 0/0'
ICMP_INPUTS_VERIFY[1]='-p icmp -m icmp --icmp-type 8/0'
ICMP_INPUTS_VERIFY[2]='-p icmp -m icmp --icmp-type 43/0'
ICMP_INPUTS_VERIFY[3]=''

METHOD_INPUTS_RESULT="0"
CLEAR_RESULT="0"
POLICY_RESULT="0"
CHAIN_RESULT="0"

EMPTY_IPTABLES[0]='# Generated by connman.*'
EMPTY_IPTABLES[1]='*filter'
EMPTY_IPTABLES[2]=':INPUT ACCEPT.*'
EMPTY_IPTABLES[3]=':FORWARD ACCEPT.*'
EMPTY_IPTABLES[4]=':OUTPUT ACCEPT.*'
EMPTY_IPTABLES[5]='COMMIT'
EMPTY_IPTABLES[6]='# Completed on.*'

CONNMAN_SAVE_FILE="/home/.system/var/lib/connman/iptables/filter.v4"

function include_sources()
{
	SCRIPTDIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

	for SRC in $SOURCES ; do
		if [ -f "$SCRIPTDIR/$SRC" ] ; then
			source "$SCRIPTDIR/$SRC"
		else
			echo "Source file \"$SCRIPTDIR/$SRC\" not available. Quitting."
			exit 1
		fi
	done
}

# $1=CHAIN $2=TARGET $3 -> rule line 
function check_save_file_rule()
{	
	if [ "$1" == "$CUSTOM_CHAIN" ] ; then
		CHAIN="sfos_$1"
	else
		CHAIN="$1"
	fi
	
	if [ "$2" == "$CUSTOM_CHAIN" ] ; then
		TARGET="sfos_$2"
	else
		TARGET="$2"
	fi
	
	if [[ $(grep -e "-A $CHAIN ${@:3} -j $TARGET" $CONNMAN_SAVE_FILE) ]] ; then
		echo 0
	else
		echo "check_save_file_rule() failure :: grep -e -A $CHAIN ${@:3} -j $TARGET ::"
	fi
}

# $1=CHAIN $2=POLICY
function check_save_file_policy()
{
	if [[ $(grep -e ":$1 $2" $CONNMAN_SAVE_FILE) ]] ; then
		echo 0
	else
		echo "check_save_file_policy() failure :: grep -e :$1 $2 ::"
	fi
}

function test_rule_ip()
{
	INDEX=0
	FAILED=0
	METHOD="RuleIp"
			
	test_begin

	for CHAIN in $TEST_CHAINS ; do
		test_progress
		for TARGET in $TEST_TARGETS ; do
			while [[ ! -z ${IP_INPUTS[$INDEX]} ]] ; do
			
				if [ "$CHAIN" != "$TARGET" ] ; then
					RULE="${IP_INPUTS[$INDEX]}"
					
					RES=$(send_rule_message "$METHOD" "ADD" "$CHAIN" "$TARGET" "$RULE")
					
					if [ "$RES" != "0" ] ; then
							log "$RES"
							FAILED=1
					fi
				fi
				
				INDEX=$((INDEX+1))
			done
			INDEX=0
		done
	done
	
	test_end "$FAILED"
}

function test_rule_ip_verify()
{
	INDEX=0
	FAILED=0
			
	test_begin

	for CHAIN in $TEST_CHAINS ; do
		test_progress
		for TARGET in $TEST_TARGETS ; do
			while [[ ! -z ${IP_INPUTS[$INDEX]} ]] ; do
			
				if [ "$CHAIN" != "$TARGET" ] ; then

					VERIFY="${IP_INPUTS_VERIFY[$INDEX]}"
					
					RES=$(check_save_file_rule "$CHAIN" "$TARGET" "$VERIFY")
					
					if [ "$RES" != "0" ] ; then
							log "$RES"
							FAILED=1
					fi
				fi
				
				INDEX=$((INDEX+1))
			done
			INDEX=1
		done
	done
	
	test_end "$FAILED"
}

function test_rule_ip_port()
{
	INDEX=0
	INDEX_IP=0
	FAILED=0
	METHOD="RuleIpWithPort"
	
	test_begin

	for CHAIN in $TEST_CHAINS ; do
		test_progress
		for TARGET in $TEST_TARGETS ; do
			while [[ ! -z ${IP_INPUTS[$INDEX_IP]} ]] ; do
				while [[ ! -z ${PORT_INPUTS[$INDEX]} ]] ; do
			
					if [ "$CHAIN" != "$TARGET" ] ; then
						RULE="${IP_INPUTS[$INDEX_IP]} ${PORT_INPUTS[$INDEX]}"
					
						RES=$(send_rule_message "$METHOD" "ADD" "$CHAIN" "$TARGET" "$RULE")
						
						if [ "$RES" != "0" ] ; then
							log "$RES"
							FAILED=1
						fi
					fi
					INDEX=$((INDEX+1))
					
				done
				INDEX=0
				INDEX_IP=$((INDEX_IP+1))
			done
			INDEX_IP=0
		done
	done
	
	test_end "$FAILED"
}

function test_rule_ip_port_verify()
{
	INDEX=0
	INDEX_IP=0
	FAILED=0
			
	test_begin

	for CHAIN in $TEST_CHAINS ; do
		test_progress
		for TARGET in $TEST_TARGETS ; do
			while [[ ! -z ${IP_INPUTS[$INDEX_IP]} ]] ; do
				while [[ ! -z ${PORT_INPUTS[$INDEX]} ]] ; do
			
					if [ "$CHAIN" != "$TARGET" ] ; then
						VERIFY="${IP_INPUTS_VERIFY[$INDEX_IP]} ${PROTO_VERIFY[$INDEX]} ${PORT_INPUTS_VERIFY[$INDEX]}"
						
						RES=$(check_save_file_rule "$CHAIN" "$TARGET" "$VERIFY")
						
						if [ "$RES" != "0" ] ; then
							log "$RES"
							FAILED=1
						fi
					fi
					INDEX=$((INDEX+1))
					
				done
				INDEX=0
				INDEX_IP=$((INDEX_IP+1))
			done
			INDEX_IP=0
		done
	done
	
	test_end "$FAILED"
}

function test_rule_ip_port_range()
{
	INDEX=0
	INDEX_IP=0
	FAILED=0
	METHOD="RuleIpWithPortRange"
	
	test_begin

	for CHAIN in $TEST_CHAINS ; do
		test_progress
		for TARGET in $TEST_TARGETS ; do
			while [[ ! -z ${IP_INPUTS[$INDEX_IP]} ]] ; do
				while [[ ! -z ${PORT_RANGE_INPUTS[$INDEX]} ]] ; do
					if [ "$CHAIN" != "$TARGET" ] ; then
						RULE="${IP_INPUTS[$INDEX_IP]} ${PORT_RANGE_INPUTS[$INDEX]}"
					
						RES=$(send_rule_message "$METHOD" "ADD" "$CHAIN" "$TARGET" "$RULE")
						
						if [ "$RES" != "0" ] ; then
							log "$RES"
							FAILED=1
						fi
					fi
					INDEX=$((INDEX+1))
				done
				INDEX=0
				INDEX_IP=$((INDEX_IP+1))
			done
			INDEX_IP=0
		done
	done
	
	test_end "$FAILED"
}

function test_rule_ip_port_range_verify()
{
	INDEX=0
	INDEX_IP=0
	FAILED=0
			
	test_begin

	for CHAIN in $TEST_CHAINS ; do
		test_progress
		for TARGET in $TEST_TARGETS ; do
			while [[ ! -z ${IP_INPUTS[$INDEX_IP]} ]] ; do
				while [[ ! -z ${PORT_RANGE_INPUTS[$INDEX]} ]] ; do
					if [ "$CHAIN" != "$TARGET" ] ; then
						VERIFY="${IP_INPUTS_VERIFY[$INDEX_IP]} ${PROTO_VERIFY[$INDEX]} ${PORT_INPUTS_VERIFY[$INDEX]}"
						
						RES=$(check_save_file_rule "$CHAIN" "$TARGET" "$VERIFY")
						
						if [ "$RES" != "0" ] ; then
							log "$RES"
							FAILED=1
						fi
					fi
					INDEX=$((INDEX+1))
				done
				INDEX=0
				INDEX_IP=$((INDEX_IP+1))
			done
			INDEX_IP=0
		done
	done
	
	test_end "$FAILED"
}

function test_rule_ip_service()
{
	INDEX=0
	INDEX_IP=0
	FAILED=0
	METHOD="RuleIpWithService"
	
	test_begin

	for CHAIN in $TEST_CHAINS ; do
		test_progress
		for TARGET in $TEST_TARGETS ; do
			while [[ ! -z ${IP_INPUTS[$INDEX_IP]} ]] ; do
				while [[ ! -z ${SERVICE_INPUTS[$INDEX]} ]] ; do
					if [ "$CHAIN" != "$TARGET" ] ; then
						RULE="${IP_INPUTS[$INDEX_IP]} ${SERVICE_INPUTS[$INDEX]}"
						
						RES=$(send_rule_message "$METHOD" "ADD" "$CHAIN" "$TARGET" "$RULE")
						
						if [ "$RES" != "0" ] ; then
							log "$RES"
							FAILED=1
						fi
					fi
					INDEX=$((INDEX+1))
				done
				INDEX=0
				INDEX_IP=$((INDEX_IP+1))
			done
			INDEX_IP=0
		done
	done
	
	test_end "$FAILED"
}

function test_rule_ip_service_verify()
{
	INDEX=0
	INDEX_IP=0
	FAILED=0
			
	test_begin

	for CHAIN in $TEST_CHAINS ; do
		test_progress
		for TARGET in $TEST_TARGETS ; do
			while [[ ! -z ${IP_INPUTS[$INDEX_IP]} ]] ; do
				while [[ ! -z ${SERVICE_INPUTS[$INDEX]} ]] ; do
					if [ "$CHAIN" != "$TARGET" ] ; then
						VERIFY="${IP_INPUTS_VERIFY[$INDEX_IP]} ${PROTO_VERIFY[$INDEX]} ${PORT_INPUTS_VERIFY[$INDEX]}"
						
						RES=$(check_save_file_rule "$CHAIN" "$TARGET" "$VERIFY")
						
						if [ "$RES" != "0" ] ; then
							log "$RES"
							FAILED=1
						fi
					fi
					INDEX=$((INDEX+1))
				done
				INDEX=0
				INDEX_IP=$((INDEX_IP+1))
			done
			INDEX_IP=0
		done
	done
	
	test_end "$FAILED"
}

function test_rule_port()
{
	INDEX=0
	FAILED=0
	METHOD="RulePort"
	
	test_begin

	for CHAIN in $TEST_CHAINS ; do
		test_progress
		for TARGET in $TEST_TARGETS ; do
			while [[ ! -z ${PORT_INPUTS[$INDEX]} ]] ; do
				if [ "$CHAIN" != "$TARGET" ] ; then
					RULE="${PORT_INPUTS[$INDEX]}"
					
					RES=$(send_rule_message "$METHOD" "ADD" "$CHAIN" "$TARGET" "$RULE")
					
					if [ "$RES" != "0" ] ; then
						log "$RES"
						FAILED=1
					fi
				fi
			
				INDEX=$((INDEX+1))
			done
			INDEX=0
		done
	done
	
	test_end "$FAILED"
}

function test_rule_port_verify()
{
	INDEX=0
	FAILED=0
	
	test_begin

	for CHAIN in $TEST_CHAINS ; do
		test_progress
		for TARGET in $TEST_TARGETS ; do
			while [[ ! -z ${PORT_INPUTS[$INDEX]} ]] ; do
				if [ "$CHAIN" != "$TARGET" ] ; then
					VERIFY="${PROTO_VERIFY[$INDEX]} ${PORT_INPUTS_VERIFY[$INDEX]}"
										
					RES=$(check_save_file_rule "$CHAIN" "$TARGET" "$VERIFY")
					
					if [ "$RES" != "0" ] ; then
						log "$RES"
						FAILED=1
					fi
				fi
			
				INDEX=$((INDEX+1))
			done
			INDEX=0
		done
	done
	
	test_end "$FAILED"
}

function test_rule_port_range()
{
	INDEX=0
	FAILED=0
	METHOD="RulePortRange"
		
	test_begin

	for CHAIN in $TEST_CHAINS ; do
		test_progress
		for TARGET in $TEST_TARGETS ; do
			while [[ ! -z ${PORT_RANGE_INPUTS[$INDEX]} ]] ; do
				if [ "$CHAIN" != "$TARGET" ] ; then
					RULE="${PORT_RANGE_INPUTS[$INDEX]}"
					
					RES=$(send_rule_message "$METHOD" "ADD" "$CHAIN" "$TARGET" "$RULE")
					
					if [ "$RES" != "0" ] ; then
						log "$RES"
						FAILED=1
					fi
				fi
			
				INDEX=$((INDEX+1))
			done
			INDEX=0
		done
	done
	
	test_end "$FAILED"
}

function test_rule_port_range_verify()
{
	INDEX=0
	FAILED=0
		
	test_begin
	
	for CHAIN in $TEST_CHAINS ; do
		test_progress
		for TARGET in $TEST_TARGETS ; do
			while [[ ! -z ${PORT_RANGE_INPUTS[$INDEX]} ]] ; do
				if [ "$CHAIN" != "$TARGET" ] ; then
					VERIFY="${PROTO_VERIFY[$INDEX]} ${PORT_INPUTS_VERIFY[$INDEX]}"
					
					RES=$(check_save_file_rule "$CHAIN" "$TARGET" "$VERIFY")
					
					if [ "$RES" != "0" ] ; then
						log "$RES"
						FAILED=1
					fi
				fi
			
				INDEX=$((INDEX+1))
			done
			INDEX=0
		done
	done
	
	test_end "$FAILED"
}

function test_rule_service()
{
	INDEX=0
	FAILED=0
	METHOD="RuleService"

	test_begin

	for CHAIN in $TEST_CHAINS ; do
		test_progress
		for TARGET in $TEST_TARGETS ; do
			while [[ ! -z ${SERVICE_INPUTS[$INDEX]} ]] ; do
				if [ "$CHAIN" != "$TARGET" ] ; then
					RULE="${SERVICE_INPUTS[$INDEX]}"
					FAILED=0
		
					RES=$(send_rule_message "$METHOD" "ADD" "$CHAIN" "$TARGET" "$RULE")
					
					if [ "$RES" != "0" ] ; then
						log "$RES"
						FAILED=1
					fi
				fi
			
				INDEX=$((INDEX+1))
			done
			INDEX=0
		done
	done
	
	test_end "$FAILED"
}

function test_rule_service_verify()
{
	INDEX=0
	FAILED=0
	
	test_begin

	for CHAIN in $TEST_CHAINS ; do
		test_progress
		for TARGET in $TEST_TARGETS ; do
			while [[ ! -z ${SERVICE_INPUTS[$INDEX]} ]] ; do
				if [ "$CHAIN" != "$TARGET" ] ; then
					VERIFY="${PROTO_VERIFY[$INDEX]} ${PORT_INPUTS_VERIFY[$INDEX]}"
					
					RES=$(check_save_file_rule "$CHAIN" "$TARGET" "$VERIFY")
					
					if [ "$RES" != "0" ] ; then
						log "$RES"
						FAILED=1
					fi
				fi
			
				INDEX=$((INDEX+1))
			done
			INDEX=0
		done
	done
	
	test_end "$FAILED"
}

function test_rule_icmp()
{
	INDEX=0
	FAILED=0
	METHOD="RuleICMP"

	test_begin

	for CHAIN in $TEST_CHAINS ; do
		test_progress
		for TARGET in $TEST_TARGETS ; do
			while [[ ! -z ${ICMP_INPUTS[$INDEX]} ]] ; do
				if [ "$CHAIN" != "$TARGET" ] ; then
					RULE="string: string: ${ICMP_INPUTS[$INDEX]}"

					RES=$(send_rule_message "$METHOD" "ADD" "$CHAIN" "$TARGET" "$RULE")
					
					if [ "$RES" != "0" ] ; then
						log "$RES"
						FAILED=1
					fi
				fi
				INDEX=$((INDEX+1))
				
			done
			INDEX=0
		done
	done

	test_end "$FAILED"
}

function test_rule_icmp_verify()
{
	INDEX=0
	FAILED=0

	test_begin

	for CHAIN in $TEST_CHAINS ; do
		test_progress
		for TARGET in $TEST_TARGETS ; do
			while [[ ! -z ${ICMP_INPUTS[$INDEX]} ]] ; do
				if [ "$CHAIN" != "$TARGET" ] ; then
					VERIFY="${ICMP_INPUTS_VERIFY[$INDEX]}"

					RES=$(check_save_file_rule "$CHAIN" "$TARGET" "$VERIFY")
					
					if [ "$RES" != "0" ] ; then
						log "$RES"
						FAILED=1
					fi
				fi
				INDEX=$((INDEX+1))
				
			done
			INDEX=0
		done
	done

	test_end "$FAILED"
}

function test_rule_icmp_ip()
{
	INDEX=0
	INDEX_IP=0
	FAILED=0
	METHOD="RuleICMP"
	
	test_begin

	for CHAIN in $TEST_CHAINS ; do
		test_progress
		for TARGET in $TEST_TARGETS ; do
			while [[ ! -z ${IP_INPUTS[$INDEX_IP]} ]] ; do
				while [[ ! -z ${ICMP_INPUTS[$INDEX]} ]] ; do
			
					if [ "$CHAIN" != "$TARGET" ] ; then
						RULE="${IP_INPUTS[$INDEX_IP]} ${ICMP_INPUTS[$INDEX]}"

						RES=$(send_rule_message "$METHOD" "ADD" "$CHAIN" "$TARGET" "$RULE")
					
						if [ "$RES" != "0" ] ; then
							log "$RES"
							FAILED=1
						fi
					fi
					INDEX=$((INDEX+1))
					
				done
				INDEX=0
				INDEX_IP=$((INDEX_IP+1))
			done
			INDEX_IP=0
		done
	done

	test_end "$FAILED"
}

function test_rule_icmp_ip_verify()
{
	INDEX=0
	FAILED=0

	test_begin

	for CHAIN in $TEST_CHAINS ; do
		test_progress
		for TARGET in $TEST_TARGETS ; do
			while [[ ! -z ${IP_INPUTS[$INDEX_IP]} ]] ; do
				while [[ ! -z ${ICMP_INPUTS[$INDEX]} ]] ; do
					if [ "$CHAIN" != "$TARGET" ] ; then
						VERIFY="${IP_VERIFY[$INDEX_IP]}.*
${ICMP_INPUTS_VERIFY[$INDEX]}"
						RES=$(check_save_file_rule "$CHAIN" "$TARGET" "$VERIFY")
	
						if [ "$RES" != "0" ] ; then
							log "$RES"
							FAILED=1
						fi
					fi
					INDEX=$((INDEX+1))
					
				done
				INDEX=0
				INDEX_IP=$((INDEX_IP+1))
			done
			INDEX_IP=0
		done
	done

	test_end "$FAILED"
}

function test_rule_pre()
{
	test_begin
	FAILED=0
		
	STATUS=$(send_message "ManageChain" "ADD" $CHAIN_RESULT "string:filter" "string:$CUSTOM_CHAIN")
	
	if [[ "$STATUS" != "0" ]] ; then
		log "$STATUS"
		FAILED=1
	fi
	
	test_progress
	
	if [ "$(id -u)" == "0" ] ; then
		STATUS=$(check_chain_added "$CUSTOM_CHAIN")
	
		if [[ "$STATUS" != "0" ]] ; then
			log "$STATUS"
			FAILED=1
		fi
	fi
	
	test_end $FAILED
}

function test_rule_post()
{
	test_begin
	FAILED=0

	CLEARED=$(send_message "ClearIptablesTable" "filter" "$CLEAR_RESULT")
	
	if [[ "$CLEARED" != "0" ]] ; then
		log "$CLEARED"
		FAILED=$((FAILED+1))
	fi
	
	test_progress
		
	STATUS=$(send_message "ManageChain" "REMOVE" $CHAIN_RESULT "string:filter" "string:$CUSTOM_CHAIN")
	
	if [[ "$STATUS" != "0" ]] ; then
		log "$STATUS"
		FAILED=1
	fi
	
	test_progress
	
	if [ "$(id -u)" == "0" ] ; then
		STATUS=$(check_chain_removed "$CUSTOM_CHAIN")
	
		if [[ "$STATUS" != "0" ]] ; then
			log "$STATUS"
			FAILED=1
		fi
	fi
	
	test_end $FAILED
}

function run_check_rules_test()
{
	INDEX=0
	FAILED=0
	
	test_begin
	
	while [[ $INDEX -lt 7 ]] ; do
	
		case "$1" in
			"INPUT")
				CHECK=$(check_save_file_rule "$1" "$2" "${METHOD_VERIFY_IN[$INDEX]}")
				;;
			"OUTPUT")
				CHECK=$(check_save_file_rule "$1" "$2" "${METHOD_VERIFY_OUT[$INDEX]}")
				;;
			*)
				;;
		esac
	
		if [[ "$CHECK" != "0" ]] ; then
			log "$CHECK"
			FAILED=1
		fi
		
		test_progress
		
		INDEX=$((INDEX+1))
	done
	
	test_end $FAILED
}


function run_add_policy_test()
{
	FAILED=0
	
	test_begin
	
	PROCESSED=$(send_message "$1" "$3" $POLICY_RESULT)
	
	test_progress
	
	if [[ "$PROCESSED" != "0" ]] ; then
		log "$PROCESSED"
		FAILED=1
	fi
	
	test_progress
	
	test_end $FAILED
}

function run_clear_test()
{
	FAILED=0
	METHODS="ClearIptablesTable ClearIptablesChains"
	
	test_begin
	
	for METHOD in $METHODS ; do
	
		CLEARED=$(send_message "$METHOD" "filter" "$CLEAR_RESULT")
	
		if [[ "$CLEARED" != "0" ]] ; then
			log "$CLEARED"
			FAILED=$((FAILED+1))
		fi
	
		test_progress
	done
	
	test_end $FAILED
}

function run_clear_test_check()
{
	INDEX=0
	FAILED=0
	
	test_begin
	
	while read line ; do
	
		if [[ ! $(echo "$line"|grep -e "${EMPTY_IPTABLES[$INDEX]}") ]] ; then
			FAILED=$((FAILED+1))
			log "Compare failed: $line - ${EMPTY_IPTABLES[$INDEX]}"
		fi
		
		INDEX=$((INDEX+1))
		test_progress
		
	done < $CONNMAN_SAVE_FILE
	
	test_end $FAILED
}

function run_custom_chain_removed_test()
{
	if [ "$(id -u)" == "0" ] ; then
	
		FAILED=0
		CHAIN="chain1"
	
		test_begin
		
		STATUS=$(send_message "ManageChain" "ADD" "0" "string:filter" "string:$CHAIN")
		
		if [[ "$STATUS" != "0" ]] ; then
			log "$STATUS"
			FAILED=1
		fi
		
		test_progress
		
		STATUS=$(check_chain_added "$CHAIN")
	
		if [[ "$STATUS" != "0" ]] ; then
			log "$STATUS"
			FAILED=$((FAILED+1))
		fi
		
		test_progress
		
		stop_service "connman"
		
		STATUS=$(check_chain_removed "$CHAIN")
	
		if [[ "$STATUS" != "0" ]] ; then
			log "$STATUS"
			FAILED=$((FAILED+1))
		fi
		
		test_progress
		
		start_service "connman"
		
		test_end $FAILED
	fi
}

function run_add_test()
{
	test_rule_pre
	
	test_rule_ip
	test_rule_ip_port
	test_rule_ip_port_range
	test_rule_ip_service
	test_rule_port
	test_rule_port_range
	test_rule_service
	test_rule_icmp
	test_rule_icmp_ip
}

function run_add_test_check()
{
	test_rule_ip_verify
	test_rule_ip_port_verify
	test_rule_ip_port_range_verify
	test_rule_ip_service_verify
	test_rule_port_verify
	test_rule_port_range_verify
	test_rule_service_verify
	test_rule_icmp_verify
	test_rule_icmp_ip_verify
}

function run_command_checks()
{
	if [ "$(id -u)" == "0" ] ; then
		for command in $REQUIRED_COMMANDS_ROOT ; do
			if [[ ! $(which "$command" 2>/dev/null) ]] ; then
				echo "Command \"$command\" is not found. Tests cannot be run."
				exit 1
			fi
		done
	else # For now user and privileged has same cmd requirements
		for command in $REQUIRED_COMMANDS_PRIV ; do
			if [[ ! $(which "$command" 2>/dev/null) ]] ; then
				echo "Command \"$command\" is not found. Tests cannot be run."
				exit 1
			fi
		done
	fi
}

function run_pre_test_operations()
{
	if [ "$(id -u)" == "0" ] ; then
		echo "Saving current iptables filter table to $IPTABLES_SAVE_FILE"
		iptables-save --table=filter > $IPTABLES_SAVE_FILE
	
		CLEARED=$(send_message "ClearIptablesTable" "filter" $CLEAR_RESULT)
	
		if [[ "$CLEARED" != "0" ]] ; then
			echo "Cannot clear iptables filter table. Test may report invalid results."
		fi
		
		CLEARED=$(send_message "ClearIptablesChains" "filter" "$CLEAR_RESULT")
	
		if [[ "$CLEARED" != "0" ]] ; then
			echo "Cannot clear chains from iptables filter table. Test may report invalid results."
		fi
	fi
}

function run_post_test_operations() 
{
	if [ "$(id -u)" == "0" ] ; then
		CLEARED=$(send_message "ClearIptablesTable" "filter" $CLEAR_RESULT)
	
		if [[ "$CLEARED" != "0" ]] ; then
			echo "Cannot clear iptables filter table."
		fi
		echo "Restoring iptables filter table from $IPTABLES_SAVE_FILE"
		iptables-restore --table=filter < $IPTABLES_SAVE_FILE
		
		stop_service "connman"
		cp -f $IPTABLES_SAVE_FILE $CONNMAN_SAVE_FILE
		start_service "connman"
		
		rm -v $IPTABLES_SAVE_FILE
	fi
}

function run_user_checks()
{
	if [ "$(id -u)" != "0" ] ; then
		echo "This test can be run only as root. Quitting"
		exit 1
	fi
}


function main()
{
	include_sources
	
	prepare_log "save-restore-test"
	
	run_user_checks 
	run_command_checks
	
	run_pre_test_operations
	
	sleep 2

	run_clear_test
	restart_service "connman"
	run_clear_test_check
	
	run_custom_chain_removed_test
	
	run_add_test
	restart_service "connman"
	run_add_test_check
	# Disable for now, find out why this fails
	#test_rule_post 
	
	run_post_test_operations
	
	test_finalize $TEST_LOG_FILE
}

main
